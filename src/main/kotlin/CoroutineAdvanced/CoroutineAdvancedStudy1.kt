package CoroutineAdvanced


/**
 * 1. 协程的分类
 * 协程的主流实现虽然细节上差异较大，但总体来讲仍然有章可循。
 *
 * 1.1 按调用栈分类
 * 由于协程需要支持挂起、恢复，因此对于挂起点的状态保存就显得极其关键。类似地，线程会因为 CPU 调度权的切换而被中断，
 * 它的中断状态会保存在调用栈当中，因而协程的实现也按照是否开辟相应的调用栈存在以下两种类型：
 * 有栈协程 Stackful Coroutine：每一个协程都会有自己的调用栈，有点儿类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。
 * 无栈协程 Stackless Coroutine：协程没有自己的调用栈，挂起点的状态通过状态机或者闭包等语法来实现。
 *
 * 有栈协程的优点就是可以在任意函数调用层级的任意位置进行挂起，并转移调度权，
 * 例如 Lua 的协程，这方面多数无栈协程就显得力不从心了，例如 Python 的 Generator；
 * 通常来讲，有栈协程因为总是会给协程开辟一块儿栈内存，因此内存开销也相对可观，而无栈协程在内存方面就比较有优势了。
 *
 * 当然也有反例。
 * Go 语言的 go routine 可以认为是有栈协程的一个实现，不过 Go 运行时在这里做了大量的优化，
 * 它的栈内存可以根据需要进行扩容和缩容，最小一般为内存页长 4KB，相比之下线程的栈空间通常是 MB 级别，
 * 因而它在内存方面的表现也相对轻量。
 *
 * Kotlin 的协程是一种无栈协程的实现，它的控制流转依靠对协程体本身编译生成的状态机的状态流转来实现，
 * 变量保存也是通过闭包语法来实现的，不过 Kotlin 的协程可以在任意调用层次挂起，换句话说我们启动一个 Kotlin 协程，
 * 可以在其中任意嵌套 suspend 函数，而这又恰恰是有栈协程最重要的特性之一
 *
 * 1.2 按调度方式分类
 * 调度过程中，根据协程转移调度权的目标又将协程分为对称协程和非对称协程：
 * 对称协程 Symmetric Coroutine：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。
 * 非对称协程 Asymmetric Coroutine：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。
 *
 * 对称协程实际上已经非常接近线程的样子了，例如 Go 语言中的 go routine 可以通过读写不同的 channel
 * 来实现控制权的自由转移。而非对称协程的调用关系实际上也更符合我们的思维方式，
 * 常见的语言对协程的实现大多是非对称实现，例如 Lua 的协程中当前协程调用 yield 总是会将调度权转移给
 * resume 它的协程；还有就是我们在前面提到的 async/await，await 时将调度权转移到异步调用中，
 * 异步调用返回结果或抛出异常时总是将调度权转移回 await 的位置。
 *
 * 从实现的角度来讲，非对称协程的实现更自然，也相对容易；不过，我们只要对非对称协程稍作修改，即可实现对称协程的能力。
 * 在非对称协程的基础上，我们只需要添加一个中立的第三方作为协程调度权的分发中心，
 * 所有的协程在挂起时都将控制权转移给分发中心，分发中心根据参数来决定将调度权转移给哪个协程，
 * 例如 Lua 的第三方库 coro(https://luapower.com/coro)，
 * 以及 Kotlin 协程框架中基于 Channel(https://kotlinlang.org/docs/reference/coroutines/channels.html) 的通信等
 */
suspend fun main() {
}